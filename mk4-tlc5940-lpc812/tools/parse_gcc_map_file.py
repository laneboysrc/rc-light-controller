#!/usr/bin/env python3
'''
parse_gcc_map_file.py

Provides a summary for FLASH and RAM usage, based on the .map file
generated by the linker.

This file is specific for the map format generated by GCC.
Hint: to generate the map file add the -Map=MAPFILENAME to the linker flags

Author:         Werner Lane
E-mail:         laneboysrc@gmail.com
'''

import sys
import os
import argparse
import re
from collections import defaultdict


FLASH = 'flash'
RAM = 'ram'


def parse_section_dict(dictionary):
    ''' Convert numbers in a section dictionary from strings to integers,
        and set the 'area' to either 'RAM' or 'FLASH' if 'writeable' is 'w'
    '''

    for key in ('start_address', 'size'):
        dictionary[key] = int(dictionary[key], 16)

    if 'writeable' in dictionary:
        if dictionary['writeable'] == 'w':
            dictionary['type'] = RAM
        else:
            dictionary['type'] = FLASH
        del dictionary['writeable']

    return dictionary


def parse_memory_sections(map_data):
    ''' Obtain the memory sections (FLASH, RAM ...) '''

    re_flags = re.MULTILINE + re.DOTALL + re.IGNORECASE + re.VERBOSE
    memory_configuration_re = r'''
        .*
        Memory\sConfiguration
        .*
        Attributes
        (.*)
        Linker\sscript\sand\smemory\smap
        .*'''

    entry_re = r'''
        (?P<section_name>\S*)
        \s+
        (?P<start_address>0x\S*)
        \s+
        (?P<size>0x\S*)
        \s+
        xr(?P<writeable>.?)
        '''

    try:
        memory_configuration = re.match(memory_configuration_re, map_data,
            flags=re_flags).group(1)

    except AttributeError:
        print("ERROR: map file does not contain memory configuration")
        sys.exit(1)

    memory_sections = []
    for match in re.finditer(entry_re, memory_configuration, flags=re_flags):
        memory_sections.append(parse_section_dict(match.groupdict()))

    return memory_sections


def parse_memory_map(map_data):
    ''' Obtain the memory map part of the map file '''

    re_flags = re.MULTILINE + re.DOTALL + re.IGNORECASE + re.VERBOSE
    memory_map_re = r'''
        .*
        Linker\sscript\sand\smemory\smap
        (.*)
        (?:Cross\sReference\sTable)?    # May or may not be present
        .*
        '''

    try:
        memory_map = re.match(memory_map_re, map_data, flags=re_flags).group(1)
    except AttributeError:
        print("ERROR: Unable to find memory map in the map file")
        sys.exit(1)

    return memory_map


def strip_directory(path):
    ''' Return the filename component of path '''
    return os.path.split(path)[1]


def get_category(section):
    ''' Categorize module names for the summary this tool outputs '''

    if section['name'] == '*fill*':
        return '(alignment waste)'

    if re.search(r'/lib.+\.a', section['module_name']):
        return '(libraries)'

    if strip_directory(section['module_name']) == 'crt0.o':
        return '(C runtime)'

    if re.match(r'.+\.o$', section['module_name']):
        return section['module_name']

    print(section['name'], section['module_name'])

    return '(others)'


def process_sections(memory_map, memory_sections):
    ''' Parse each section that does not have an intializer '''
    re_flags = re.VERBOSE + re.MULTILINE
    section_re = r'''
        ^
        [ ]\.?(?P<name>\S+?)
        \s+
        (?P<start_address>0x\S+)
        [ ]+                        # Match spaces, not \s which matches \n!
        (?P<size>0x\S+)
        [ ]+
        (?P<module_name>.*)
        $
        '''

    sections_to_ignore = ("ARM.attributes", "comment")
    totals = dict(ram=defaultdict(int), flash=defaultdict(int))

    for match in re.finditer(section_re, memory_map, flags=re_flags):
        section = parse_section_dict(match.groupdict())

        if section['size'] == 0:
            continue

        if section['name'] in sections_to_ignore:
            continue

        if section['name'].startswith('debug_'):
            continue


        for memory_section in memory_sections:
            start = memory_section['start_address']
            size = memory_section['size']
            end = start + size
            if start <= section['start_address'] <= end:
                section['memory'] = memory_section['type']
                break

        category = get_category(section)
        totals[section['memory']][category] += section['size']

    return totals


def print_summary(totals, sort):
    ''' Output the summary of memory usage '''
    summary = dict()

    for flash in totals[FLASH]:
        summary[flash] = dict(
            flash=totals[FLASH][flash], ram=0, module_name=flash)

    for ram in totals[RAM]:
        if ram in summary:
            summary[ram][RAM] = totals[RAM][ram]
        else:
            summary[ram] = dict(
                ram=totals[RAM][ram], flash=0, module_name=ram)

    print('Module                              |     FLASH |       RAM')
    print('------------------------------------+-----------+-----------')

    total_flash = 0
    total_ram = 0

    for entry in sorted(summary, key=lambda item: summary[item][sort]):
        total_flash += summary[entry][FLASH]
        total_ram += summary[entry][RAM]
        print('{:35} | {:9} | {:9}'.format(
            entry, summary[entry][FLASH], summary[entry][RAM]))

    print('------------------------------------+-----------+-----------')
    print('{:35} | {:9} | {:9}'.format('TOTAL:', total_flash, total_ram))
    print('------------------------------------+-----------+-----------')


def map_file_parser(args):
    ''' Parse the map file and print FLASH and RAM summary information '''
    map_data = args.mapfile[0].read()

    memory_sections = parse_memory_sections(map_data)
    memory_map = parse_memory_map(map_data)
    totals = process_sections(memory_map, memory_sections)
    print_summary(totals, args.sort)


def parse_commandline():
    ''' Simulate a receiver with built-in preprocessor '''
    parser = argparse.ArgumentParser(
        description="Simulate a receiver with built-in preprocessor.")

    parser.add_argument("-s", "--sort", choices=['flash', 'ram'],
        default='module_name',
        help="""sort the output by flash or ram size. Default is sort by
        module name""")

    parser.add_argument("mapfile", nargs=1, type=argparse.FileType('r'),
        help="the filename of the map file to summarize")

    return parser.parse_args()


def main():
    ''' Program start '''
    try:
        args = parse_commandline()
        map_file_parser(args)
    except KeyboardInterrupt:
        print("")
        sys.exit(0)


if __name__ == '__main__':
    main()
